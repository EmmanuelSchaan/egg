\documentclass[12pt,a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{graphics,graphicx}
\usepackage{txfonts}
\usepackage{natbib}
\usepackage[svgnames]{xcolor}
\usepackage{xspace}
\usepackage[colorlinks=true,linkcolor=blue,linktoc=page]{hyperref}
\usepackage{etoolbox}
\usepackage{lastpage}
\usepackage{sidecap}
\usepackage{minted}
% \usepackage[cm]{fullpage}
\usepackage[a4paper,headsep=5pt,footskip=23pt]{geometry}

\makeatletter

% Patch case where name and year are separated by aysep
\patchcmd{\NAT@citex}
  {\@citea\NAT@hyper@{%
     \NAT@nmfmt{\NAT@nm}%
     \hyper@natlinkbreak{\NAT@aysep\NAT@spacechar}{\@citeb\@extra@b@citeb}%
     \NAT@date}}
  {\@citea\NAT@nmfmt{\NAT@nm}%
   \NAT@aysep\NAT@spacechar\NAT@hyper@{\NAT@date}}{}{}

% Patch case where name and year are separated by opening bracket
\patchcmd{\NAT@citex}
  {\@citea\NAT@hyper@{%
     \NAT@nmfmt{\NAT@nm}%
     \hyper@natlinkbreak{\NAT@spacechar\NAT@@open\if*#1*\else#1\NAT@spacechar\fi}%
       {\@citeb\@extra@b@citeb}%
     \NAT@date}}
  {\@citea\NAT@nmfmt{\NAT@nm}%
   \NAT@spacechar\NAT@@open\if*#1*\else#1\NAT@spacechar\fi\NAT@hyper@{\NAT@date}}
  {}{}

\makeatother


\newcommand{\phypp}{\textit{phy}$_{\text{++}}$\xspace}
\newcommand{\cpp}[1]{\texttt{#1}\xspace}
\newcommand{\stdvec}{\cppinline|std::vector|\xspace}
\newcommand{\egg}{\textsc{EGG}\xspace}
\newcommand{\skymaker}{\textit{SkyMaker}\xspace}
\newcommand{\sextractor}{\textit{SExtractor}\xspace}
\newcommand{\tphot}{\textit{T-PHOT}\xspace}
\newcommand{\bash}{\textit{bash}\xspace}

\newminted{cpp}{fontsize=\small}
\newmintinline{cpp}{fontsize=\small}
\newminted{bash}{fontsize=\small}
\newmintinline{bash}{fontsize=\small}
\newminted{idl}{fontsize=\small}
\newmintinline{idl}{fontsize=\small}
\newminted{python}{fontsize=\small}
\newmintinline{python}{fontsize=\small}

\newcommand{\anote}[2]{{\color{cyan}#1}: {\color{blue} #2}}
\newcommand{\rephrase}[1]{{\color{pink}Reformulate}: {\color{red}\it #1}}
\newcommand{\cneeded}{{\color{red}(citation needed)}\xspace}
\newcommand{\todo}[1]{{\color{teal}TODO: #1}\xspace}
\newcommand{\tabnote}[1]{$^{\rm #1}$\xspace}
\newcommand{\tabnotep}[1]{\tabnote{(#1)}\xspace}
\newcommand{\hlink}[1]{\url{http://#1}\xspace}
\newcommand{\changed}[1]{#1}

\newcommand{\rfig}[1]{Fig.~\ref{#1}}
\newcommand{\rfigs}[1]{Figs.~\ref{#1}}
\newcommand{\req}[1]{Eq.~\ref{#1}}
\newcommand{\reqs}[1]{Eqs.~\ref{#1}}
\newcommand{\rtab}[1]{Table \ref{#1}}
\newcommand{\rtabs}[1]{Tables \ref{#1}}
\newcommand{\rapp}[1]{Appendix \ref{#1}}
\newcommand{\rapps}[1]{Appendices \ref{#1}}
\newcommand{\rsec}[1]{subsection \ref{#1}}
\newcommand{\rsecs}[1]{sections \ref{#1}}
\newcommand{\rfnote}[1]{footnote \ref{#1}}
\newcommand{\rfnotes}[1]{footnotes \ref{#1}}

\newcommand{\via}{{\it via}\xspace}

\newcommand{\herschel}{{\it Herschel}\xspace}
\newcommand{\spitzer}{{\it Spitzer}\xspace}
\newcommand{\hubble}{{\it Hubble}\xspace}
\newcommand{\hst}{{\it HST}\xspace}
\newcommand{\jwst}{{\it JWST}\xspace}
\newcommand{\subaru}{{\it Subaru}\xspace}
\newcommand{\GALEX}{{\it GALEX}\xspace}

\newcommand{\um}{\mu{\rm m}}
\newcommand{\uJy}{\mu{\rm Jy}}
\newcommand{\mJy}{{\rm mJy}}
\newcommand{\mad}{{\rm MAD}}
\newcommand{\nmad}{{\rm NMAD}}
\newcommand{\median}[1]{\left<#1\right>}
\newcommand{\mean}[1]{\left<#1\right>}
\newcommand{\logd}{\log_{10}}
\newcommand{\sfr}{{\rm SFR}}
\newcommand{\sfruv}{{\rm SFR}_{\rm UV}}
\newcommand{\sfrir}{{\rm SFR}_{\rm IR}}
\newcommand{\sfrms}{{\rm SFR}_{\rm MS}}
\newcommand{\ssfr}{{\rm sSFR}}
\newcommand{\lir}{L_{\rm IR}}
\newcommand{\lfir}{L_{\rm FIR}}
\newcommand{\irx}{\rm IRX}
\newcommand{\leight}{L_8}
\newcommand{\ireight}{{\rm IR8}}
\newcommand{\cplus}{[\ion{C}{II}]}
\newcommand{\luv}{L_{\rm UV}}
\newcommand{\lsun}{L_\odot}
\newcommand{\msun}{{\rm M}_\odot}
\newcommand{\mdense}{{\rm M}_{\rm dense}}
\newcommand{\mgas}{{\rm M}_{\rm gas}}
\newcommand{\mhalo}{{\rm M}_{\rm halo}}
\newcommand{\fgas}{f_{\rm gas}}
\newcommand{\Mpc}{{\rm Mpc}}
\newcommand{\Gyr}{{\rm Gyr}}
\newcommand{\Myr}{{\rm Myr}}
\newcommand{\yr}{{\rm yr}}
\newcommand{\dex}{{\rm dex}}
\newcommand{\mstar}{M_\ast}
\newcommand{\snr}{{\rm SNR}}
\newcommand{\snu}{S_{\!\nu}}
\newcommand{\tdust}{T_{\rm dust}}
\newcommand{\rhosfr}{\rho_{\sfr}}
\newcommand{\rhostar}{\rho_{\ast}}
\newcommand{\rsb}{R_{\rm SB}}
\newcommand{\uvj}{$UVJ$\xspace}
\newcommand{\bzk}{$BzK$\xspace}
\newcommand{\bt}{B/T}
\newcommand{\rdisk}{R_{\rm disk}}
\newcommand{\rbulge}{R_{\rm bulge}}
\newcommand{\sersic}{S\'ersic\xspace}

\newcommand{\halpha}{${\rm H}_\alpha$\xspace}
\newcommand{\Ks}{$K_{\rm s}$\xspace}
\newcommand{\celib}{CE01\xspace}
\newcommand{\galfit}{{\sc Galfit}\xspace}

\newcommand\efp{%
  \newgeometry{left=1.8cm,bottom=2.0cm,right=1.8cm,top=1.8cm} %
  \resetHeadWidth %
  \renewcommand{\headrulewidth}{0.4pt} %
  \noindent %
}

\makeatletter
\newcommand{\resetHeadWidth}{\fancy@setoffs}
\makeatother

% Alter some LaTeX defaults for better treatment of figures:
% See p.105 of "TeX Unbound" for suggested values.
% See pp. 199-200 of Lamport's "LaTeX" book for details.
%   General parameters, for ALL pages:
\renewcommand{\topfraction}{0.95}  % max fraction of floats at top
\renewcommand{\bottomfraction}{0.8} % max fraction of floats at bottom
%   Parameters for TEXT pages (not float pages):
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{4}     % 2 may work better
\setcounter{dbltopnumber}{2}    % for 2-column pages
\renewcommand{\dbltopfraction}{0.9} % fit big float above 2-col. text
\renewcommand{\textfraction}{0.07}  % allow minimal text w. figs
%   Parameters for FLOAT pages (not text pages):
\renewcommand{\floatpagefraction}{0.9}  % require fuller float pages
% N.B.: floatpagefraction MUST be less than topfraction !!
\renewcommand{\dblfloatpagefraction}{0.9} % require fuller float pages

\begin{document}
\newgeometry{left=1.8cm,bottom=2.0cm,right=1.8cm,top=1.8cm}

\begin{center}
{\huge Generating mock catalogs with \egg}
\end{center}

\tableofcontents

\section{Installing \egg}

\input{doc-install}

\section{Using \egg}

As you may have seen from the previous section, \egg is actually composed of several different tools, each taking care of a different step of the simulation process:
\begin{itemize}
\item \bashinline{egg-gencat}: creates a new \egg mock catalog,
\item \bashinline{egg-getsed}: pick the complete spectrum of a galaxy from an SED data base created by \bashinline{egg-gencat},
\item \bashinline{egg-2skymaker}: convert an \egg catalog into a \skymaker input catalog,
\item \bashinline{egg-gennoise}: create an empty image with noise,
\item \bashinline{egg-genmap}: paint galaxies from an \egg catalog to an empty map created with \bashinline{egg-gennoise}.
\end{itemize}

In this section, I will describe the features and capabilities of each of these programs. You can refer to this documentation if you need help understanding this or that command line argument, or if you want to discover new features that you didn't know existed. Alternatively, each program can provide you with some limited help on the spot, if you simply call
\begin{bashcode}
egg-[xxx] help
\end{bashcode}
in the terminal (where \bashinline{[xxx]} is to be replaced by the name of the program you want the help for).

\subsection{Generic information (applies to all programs)}

\subsubsection{Command line arguments}

All the tools in the \egg suite are compiled into binary executables. This means you do not need to run Python, IDL, or any other interpreter to launch them. It also means they are fast!

To specify the parameters of each programs, \egg relies exclusively on command line arguments, rather than configuration files (as done, e.g., with \tphot, \skymaker or \sextractor). The reason why is that it allows easy scripting with \bash (or your favorite shell), and also allows you to experiment and tweak the parameters directly inside the terminal rather than having to go back and forth between the terminal and the configuration file.

The syntax for command line arguments is simple: \bashinline{variable=value} or \bashinline{-variable=value} (the two are perfectly equivalent). Spaces are not allowed on either side of the \bashinline{=} sign, and if \bashinline{value} contains spaces, you must wrap it within double quotes: \bashinline{variable="some value"}. If you want to provide an array of values, the syntax is: \bashinline{variable=[value1,value2,...]}, with no space. If at least one of the values does contain a space, you must wrap the whole array within double quotes: \\
\bashinline{variable="[some value1,value2 foo,...]"}\\
(in this case, spaces can be used freely within the quotes). Lastly, if you want to provide multiple command line arguments, simply put one (or more) space between each argument: \bashinline{x1=10 x2=5}. The order of the arguments does not matter.

Regarding the \emph{type} of the argument. From the command line, everything is a string of characters. So there is no difference between \bashinline{"0.08"} and \bashinline{0.08}, or \bashinline{"foo"} and \bashinline{foo}. The values that you provide are translated into numbers/booleans/whatever by the program, using the standard C++ parsing. This means in particular that you can use scientific notation for large/small numbers (\bashinline{-1e56}). Also, if the parameter that you want to modify is a boolean (i.e., either \cppinline{0} or \cppinline{1}), you can simply write the command line argument as: \bashinline{variable} (without a value), which is equivalent to \bashinline{variable=1}.

Some examples:
\begin{bashcode}
egg-gencat area=0.08        # good
egg-gencat area = 0.08      # bad! don't put spaces around '='

egg-gencat note="my catalog v1.0" # good
egg-gencat note=my catalog v1.0   # bad! missing the quotes "..."

egg-gencat area=0.08 zmin=2 # good
egg-gencat area=0.08zmin=2  # bad! need a space between each argument

egg-gencat bands=[hst-f160w,spitzer-irac1]    # good
egg-gencat bands="[hst-f160w,spitzer-irac1]"  # good also
egg-gencat bands=[hst-f160w, spitzer-irac1]   # bad! cannot use a space in the array
egg-gencat bands="[hst-f160w, spitzer-irac1]" # good! with the quotes, it is fine
\end{bashcode}

\subsubsection{Column-oriented FITS tables}

For historical reasons tied to IDL, \egg and \phypp (the underlying C++ library) exclusively support column-oriented FITS tables. Although this is a perfectly valid way of doing things (according to the FITS standard), this is not the standard way FITS tables are used in community. It has, however, a number of advantages that I will not describe here (take a look at the \phypp documentation if you are interested). Instead, this section will tell you how you can read and write such kind of FITS tables.

{\bf In C++.} Using the \phypp library, reading and writing these tables is natural:
\begin{cppcode}
// First declare the columns you want to read (here: 1D columns of doubles)
vec1d m, z, ra, dec;

// Then read them from the file (order is irrelevant)
fits::read_table("the_file.fits", ftable(m, z, ra, dec));

// Now you can do whatever you want with these columns
m += 1+z; // some silly stuff

// Writing is as simple
fits::write_table("new_file.fits", ftable(m, z, ra, dec));
\end{cppcode}
Only the columns you need are actually read from the file, and the type of the variables you declare in C++ has to match the type of the columns that are found inside the FITS table. Diagnostics will be given if this is not the case. See the \phypp documentation for more detail.

{\bf In IDL.} Column-oriented FITS tables can be read using \bashinline{mrdfits}, and written using \bashinline{mwrfits}:
\begin{idlcode}
; Read the whole table
tbl = mrdfits('the_file.fits', 1, /silent)

; Now you can do whatever you want with these columns
tbl.m += 1+tbl.z ; some silly stuff

; Writing is as simple
mwrfits, tbl, 'new_file.fits', /create
\end{idlcode}
Contrary to the C++ version, these functions can only read the whole table at once, not specific columns. This can be convenient, but also inefficient. Be careful not to forget the \idlinline{/create} keyword, else the function will create a new extension to the FITS file if it already exists.

{\bf In Python.} Column-oriented FITS tables are not well supported by the standard FITS I/O module from \bashinline{astropy} (you can use \pythoninline{astropy.io.fits}, but it will be a bit cumbersome). However I have written a small module that implements this, you can download it \href{https://github.com/cschreib/phypp/blob/master/python/pycolfits.py}{[here]}. Usage is as simple as above:
\begin{pythoncode}
import pycolfits

# Read the whole table
tbl = pycolfits.readfrom('the_file.fits')

# Now you can do whatever you want with these columns
tbl['m'] += 1+tbl['z'] # some silly stuff

# Writing is as simple
pycolfits.writeto('new_file.fits', tbl, clobber=True)
\end{pythoncode}
As for the IDL version, do not forget the \pythoninline{clobber=True} argument, else the function will throw an exception if the file already exists (I don't like this, but looking at the rest of the \bashinline{astropy} library it seems to be the expected behavior).

{\bf In Topcat.} If you use a language that does not support column-oriented tables, you can always use Topcat to open these tables and convert them into a format of your choosing (would it be ASCII or some other FITS format). Be sure to load the FITS table as ``colfit-basic''. Unfortunately it does not support all the features of column-oriented tables, so all but the simplest files will be rejected. Consider instead investing time learning one of the above languages (and maybe not IDL).


\subsection{\bashinline{egg-gencat}}

\subsubsection{Basic usage}
This is the main program of the \egg suite. It will create a new mock catalog from scratch. You simply have to describe the parameters of the survey you want to simulate, i.e., the area of the sky that is covered (in square degrees), the depth (in AB magnitude) and the selection band. This is the standard way of using the software:
\begin{bashcode}
egg-gencat area=0.08 maglim=28 selection_band=hst-f160w
\end{bashcode}
This will create a new catalog in a FITS table called \bashinline{egg-[yyyymmdd].fits}, where \bashinline{[yyyymmdd]} is the current date. The name of this file can also be chosen using the command line parameter \bashinline{out}:
\begin{bashcode}
egg-gencat area=0.08 maglim=28 selection_band=hst-f160w out=some_folder/mycatalog.fits
\end{bashcode}

\subsubsection{Choosing a seed}
The catalog is created using a random number generator and a set of recipes. However, even with the random number generator, running the above commands will always produce the same catalog. This is because the same random \emph{seed} is used every time. The seed basically sets the starting point of the random number generator: choosing a slightly different seed will result in a completely different catalog. By default, this seed is chosen to be equal to the arbitrary value of \cppinline{42}. You can change this value using the command line argument \bashinline{seed}:
\begin{bashcode}
egg-gencat area=0.08 maglim=28 selection_band=hst-f160w seed=1456518
\end{bashcode}
The value of the seed can be any positive integer number (including 0) that your computer can handle (that is, a 32bit or 64bit integer depending on the architecture of your CPU). Nobody knows what is the seed of our own Universe, so feel free to use whatever value you like.

\subsubsection{Providing your own galaxies}
The first step of the program is to generate the galaxies, with their position on the sky, their redshift, their stellar mass, and their star-forming classification (i.e., each galaxy is either star-forming or quiescent according to the \uvj diagram). This is done using the stellar-mass functions that I observed in the GOODS--South field combined with observations in the Local Universe, and this should be fairly realistic between $z=0$ to $z=3$. However, the program also gives you the opportunity to provide these parameters yourself. You could, for example, provide a true (observed) catalog of galaxies, and let the program run its recipes to predict the fluxes of each object.

To do so, you must first create an input catalog suitable for ingestion by \bashinline{egg-gencat}. The program accepts two file formats: either a FITS table or a plain ASCII table. The FITS table must be a column-oriented FITS table.

\subsection{\bashinline{egg-getsed}}
\subsection{\bashinline{egg-2skymaker}}
\subsection{\bashinline{egg-gennoise}}
\subsection{\bashinline{egg-genmap}}

\end{document}

